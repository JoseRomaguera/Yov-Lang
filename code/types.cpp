constexpr Object _make_object(VariableType* vtype) {
    Object obj{};
    obj.vtype = vtype;
    return obj;
}
constexpr VariableType _make_vtype(VTypeID ID, VariableType* child, const char* name, u32 name_size) {
    VariableType type{};
    type.ID = ID;
    type.name.size = name_size;
    type.name.data = (char*)name;
    type.kind = VariableKind_Unknown;
    type.child_next = child;
    type.child_base = child;
    return type;
}

read_only VariableType _nil_vtype = _make_vtype(VTypeID_Unknown, &_nil_vtype, "Unknown", sizeof("Unknown"));
read_only VariableType _void_vtype = _make_vtype(VTypeID_Void, &_nil_vtype, "void", sizeof("void"));

read_only Object _nil_obj = _make_object(&_nil_vtype);
read_only Object _null_obj = _make_object(&_void_vtype);

VariableType* nil_vtype = &_nil_vtype;
VariableType* void_vtype = &_void_vtype;

Object* nil_obj = &_nil_obj;
Object* null_obj = &_null_obj;

#include "autogenerated/core.h"

inline_fn void vtype_add_core(VariableKind kind, String name, u64 assert_vtype) {
    VariableType* vtype = vtype_add(kind, name, nil_vtype, nil_vtype);
    assert(vtype->ID == assert_vtype);
}

void types_initialize(b32 import_core)
{
    yov->vtype_table = pooled_array_make<VariableType>(yov->static_arena, 32);
    yov->functions = pooled_array_make<FunctionDefinition>(yov->static_arena, 32);
    yov->arg_definitions = pooled_array_make<ArgDefinition>(yov->static_arena, 32);
    yov->globals = pooled_array_make<ObjectDefinition>(yov->static_arena, 32);
    
    vtype_add_core(VariableKind_Any, "Any", VTypeID_Any);
    vtype_add_core(VariableKind_Primitive, "Int", VTypeID_Int);
    vtype_add_core(VariableKind_Primitive, "Bool", VTypeID_Bool);
    vtype_add_core(VariableKind_Primitive, "String", VTypeID_String);
    
    {
        VariableTypeChild string_properties[] = {
            VariableTypeChild{ false, STR("size"), 0, VType_Int }
        };
        
        VariableTypeChild array_properties[] = {
            VariableTypeChild{ false, STR("count"), 0, VType_Int }
        };
        
        VariableTypeChild enum_properties[] = {
            VariableTypeChild{ false, STR("index"), 0, VType_Int },
            VariableTypeChild{ false, STR("value"), 1, VType_Int },
            VariableTypeChild{ false, STR("name"), 2, VType_String }
        };
        
        yov->string_properties = array_copy(yov->static_arena, array_make(string_properties, countof(string_properties)));
        yov->array_properties = array_copy(yov->static_arena, array_make(array_properties, countof(array_properties)));
        yov->enum_properties = array_copy(yov->static_arena, array_make(enum_properties, countof(enum_properties)));
    }
    
    if (import_core) define_core();
}

VariableType* vtype_add(VariableKind kind, String name, VariableType* child_next, VariableType* child_base)
{
    u64 ID = yov->vtype_table.count + 1;
    VariableType* type = array_add(&yov->vtype_table);
    type->ID = ID;
    type->kind = kind;
    type->name = string_copy(yov->static_arena, name);
    type->child_base = child_base;
    type->child_next = child_next;
    return type;
}

VariableType* vtype_get(VTypeID ID) {
    if (ID == VTypeID_Void) return void_vtype;
    u32 index = (u32)ID - 1;
    if (index < 0 || index >= yov->vtype_table.count) return nil_vtype;
    return &yov->vtype_table[index];
}

VariableType* vtype_from_dimension(VariableType* element, u32 dimension)
{
    SCRATCH();
    if (dimension == 0) return element;
    
    for (auto it = pooled_array_make_iterator(&yov->vtype_table); it.valid; ++it) {
        VariableType* type = it.value;
        if (type->kind != VariableKind_Array) continue;
        if (type->array_dimensions != dimension) continue;
        if (type->child_base->ID != element->ID) continue;
        return type;
    }
    
    VariableType* child_base = element;
    VariableType* child_next = (dimension == 1) ? child_base : vtype_from_dimension(element, dimension - 1);
    String name = string_format(scratch.arena, "%S[]", child_next->name);
    
    VariableType* type = vtype_add(VariableKind_Array, name, child_next, child_base);
    type->array_dimensions = dimension;
    
    return type;
}

b32 vtype_is_enum(VariableType* vtype) { return vtype->kind == VariableKind_Enum; }
b32 vtype_is_array(VariableType* vtype) { return vtype->kind == VariableKind_Array; }
b32 vtype_is_struct(VariableType* vtype) { return vtype->kind == VariableKind_Struct; }
b32 vtype_is_tuple(VariableType* vtype) { return vtype_is_struct(vtype) && vtype->_struct.is_tuple; }

VariableType* vtype_from_name(String name)
{
    u32 dimensions = 0;
    while (name.size > 2 && name[name.size - 1] == ']' && name[name.size - 2] == '[') {
        name = string_substring(name, 0, name.size - 2);
        dimensions++;
    }
    
    for (auto it = pooled_array_make_iterator(&yov->vtype_table); it.valid; ++it) {
        if (string_equals(it.value->name, name)) {
            return vtype_from_dimension(it.value, dimensions);
        }
    }
    return nil_vtype;
}

u32 vtype_get_size(VariableType* vtype) {
    if (vtype->ID == VTypeID_Void) return sizeof(Object);
    if (vtype->ID == VTypeID_Int) return sizeof(Object_Int);
    if (vtype->ID == VTypeID_Bool) return sizeof(Object_Bool);
    if (vtype->ID == VTypeID_String) return sizeof(Object_String);
    
    if (vtype->kind == VariableKind_Array) return sizeof(Object_Array);
    if (vtype->kind == VariableKind_Enum) return sizeof(Object_Enum);
    if (vtype->kind == VariableKind_Struct) return sizeof(Object_Struct);
    
    invalid_codepath();
    return sizeof(Object);
}

VariableType* vtype_get_child_at(VariableType* vtype, u32 index, b32 is_member)
{
    if (is_member)
    {
        if (vtype->kind == VariableKind_Array) {
            return vtype->child_next;
        }
        else if (vtype->kind == VariableKind_Struct) {
            Array<VariableType*> vtypes = vtype->_struct.vtypes;
            if (index >= vtypes.count) return nil_vtype;
            return vtypes[index];
        }
    }
    else
    {
        // TODO(Jose): 
        invalid_codepath();
    }
    
    return nil_vtype;
}

VariableTypeChild vtype_get_child(VariableType* vtype, String name)
{
    VariableTypeChild info = vtype_get_member(vtype, name);
    if (info.index >= 0) return info;
    return vtype_get_property(vtype, name);
}

VariableTypeChild vtype_get_member(VariableType* vtype, String member)
{
    if (vtype->kind == VariableKind_Struct) {
        Array<String> names = vtype->_struct.names;
        foreach(i, names.count) {
            if (string_equals(names[i], member)) {
                return { true, names[i], (i32)i, vtype->_struct.vtypes[i] };
            }
        }
    }
    
    return { true, "", -1, nil_vtype };
}

VariableTypeChild vtype_get_property(VariableType* vtype, String property)
{
    Array<VariableTypeChild> props = vtype_get_properties(vtype);
    foreach(i, props.count) {
        if (string_equals(props[i].name, property)) return props[i];
    }
    return { false, "", -1, nil_vtype };
}

Array<VariableTypeChild> vtype_get_properties(VariableType* vtype)
{
    if (vtype->ID == VTypeID_String) return yov->string_properties;
    if (vtype->kind == VariableKind_Array) return yov->array_properties;
    if (vtype->kind == VariableKind_Enum) return yov->enum_properties;
    return {};
}

Array<VariableType*> vtype_unpack(Arena* arena, VariableType* vtype)
{
    if (!vtype_is_struct(vtype)) {
        Array<VariableType*> vtypes = array_make<VariableType*>(arena, 1);
        vtypes[0] = vtype;
        return vtypes;
    }
    
    return vtype->_struct.vtypes;
}

VariableType* vtype_from_node(OpNode_ObjectType* node, b32 allow_reference)
{
    if (!allow_reference && node->is_reference) {
        report_reftype_invalid(node->code);
        return nil_vtype;
    }
    if (node->name.size == 0) return void_vtype;
    VariableType* vtype = vtype_from_name(node->name);
    vtype = vtype_from_dimension(vtype, node->array_dimensions);
    if (vtype == nil_vtype) report_object_type_not_found(node->code, node->name);
    return vtype;
}

VariableType* vtype_from_binary_operation(VariableType* left, VariableType* right, BinaryOperator op)
{
    if (left->ID == VTypeID_Int && right->ID == VTypeID_Int) {
        if (binary_operator_is_arithmetic(op)) return VType_Int;
        
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
        if (op == BinaryOperator_LessThan) return VType_Bool;
        if (op == BinaryOperator_LessEqualsThan) return VType_Bool;
        if (op == BinaryOperator_GreaterThan) return VType_Bool;
        if (op == BinaryOperator_GreaterEqualsThan) return VType_Bool;
    }
    
    if (left->ID == VTypeID_Bool && right->ID == VTypeID_Bool) {
        if (op == BinaryOperator_LogicalOr) return VType_Bool;
        if (op == BinaryOperator_LogicalAnd) return VType_Bool;
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->ID == VTypeID_String && right->ID == VTypeID_String)
    {
        if (op == BinaryOperator_Addition) return VType_String;
        if (op == BinaryOperator_Division) return VType_String;
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->ID == VType_Type->ID && right->ID == VType_Type->ID)
    {
        if (op == BinaryOperator_Equals) return VType_Bool;
        else if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if ((left->ID == VTypeID_String && right->ID == VTypeID_Int) || (left->ID == VTypeID_Int && right->ID == VTypeID_String))
    {
        if (op == BinaryOperator_Addition) return VType_String;
    }
    
    if (left->kind == VariableKind_Enum && right->kind == VariableKind_Enum) {
        if (op == BinaryOperator_Equals) return VType_Bool;
        else if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->child_next->ID == right->child_next->ID && left->kind == VariableKind_Array && right->kind == VariableKind_Array) {
        if (op == BinaryOperator_Addition) return left;
    }
    
    if ((left->kind == VariableKind_Array && right->kind != VariableKind_Array) || (left->kind != VariableKind_Array && right->kind == VariableKind_Array))
    {
        VariableType* array_type = (left->kind == VariableKind_Array) ? left : right;
        VariableType* element_type = (left->kind == VariableKind_Array) ? right : left;
        
        if (array_type->child_next->ID == element_type->ID) {
            if (op == BinaryOperator_Addition) return array_type;
        }
    }
    
    return nil_vtype;
}

VariableType* vtype_from_sign_operation(VariableType* src, BinaryOperator op)
{
    if (src->ID == VTypeID_Int) {
        if (op == BinaryOperator_Addition) return VType_Int;
        if (op == BinaryOperator_Substraction) return VType_Int;
    }
    
    if (src->ID == VTypeID_Bool) {
        if (op == BinaryOperator_LogicalNot) return VType_Bool;
    }
    
    return nil_vtype;
}

VariableType* define_enum(String name, Array<String> names, Array<i64> values)
{
    SCRATCH();
    
    if (values.count == 0) {
        values = array_make<i64>(scratch.arena, names.count);
        foreach(i, values.count) values[i] = i;
    }
    
    names = array_copy(yov->static_arena, names);
    values = array_copy(yov->static_arena, values);
    
    VariableType* t = vtype_add(VariableKind_Enum, name, nil_vtype, nil_vtype);
    t->_enum.names = names;
    t->_enum.values = values;
    assert(names.count == values.count);
    
    // .array
    {
        VariableType* array_vtype = vtype_from_dimension(t, 1);
        Array<Value> elements = array_make<Value>(scratch.arena, names.count);
        foreach(i, elements.count) {
            elements[i] = value_from_enum(t, i);
        }
        Value value = value_from_array(yov->static_arena, array_vtype, elements);
        IR ir = ir_generate_from_value(value);
        define_global(obj_def_make(string_format(scratch.arena, "$%S_array", name), array_vtype, true, false, ir));
    }
    
    return t;
}

VariableType* define_struct(String name, Array<ObjectDefinition> members, OpNode_StructDefinition* node, b32 is_tuple)
{
    Array<String> names = array_make<String>(yov->static_arena, members.count);
    Array<VariableType*> vtypes = array_make<VariableType*>(yov->static_arena, members.count);
    Array<IR> irs = array_make<IR>(yov->static_arena, members.count);
    
    foreach(i, vtypes.count)
    {
        ObjectDefinition member = members[i];
        assert(!member.is_reference);
        names[i] = member.name;
        vtypes[i] = member.vtype;
        irs[i] = member.ir;
        
        if (vtypes[i] < 0) return nil_vtype;
    }
    
    VariableType* t = vtype_add(VariableKind_Struct, name, nil_vtype, nil_vtype);
    t->_struct.node = node;
    t->_struct.names = names;
    t->_struct.vtypes = vtypes;
    t->_struct.irs = irs;
    t->_struct.is_tuple = is_tuple;
    return t;
}

void define_arg(String identifier, String name, Value value, b32 required, String description)
{
    ArgDefinition arg{};
    arg.identifier = identifier;
    arg.name = name;
    arg.vtype = value.vtype;
    arg.required = required;
    arg.description = description;
    
    array_add(&yov->arg_definitions, arg);
    
    IR ir = ir_generate_from_value(value);
    define_global(obj_def_make(identifier, value.vtype, true, false, ir));
}

internal_fn VariableType* calculate_return_vtype_for_fn(FunctionDefinition* fn, Array<ObjectDefinition> returns)
{
    SCRATCH();
    
    if (returns.count == 0) return void_vtype;
    
    if (returns.count == 1 && string_equals(returns[0].name, "return")) {
        return returns[0].vtype;
    }
    
    return define_struct(string_format(scratch.arena, "%S_return", fn->identifier), returns, NULL, true);
}

void define_function(CodeLocation code, String identifier, Array<ObjectDefinition> parameters, Array<ObjectDefinition> returns, OpNode_Block* block)
{
    FunctionDefinition fn{};
    fn.identifier = identifier;
    fn.parameters = array_copy(yov->static_arena, parameters);
    fn.returns = array_copy(yov->static_arena, returns);
    fn.defined.ir = {}; // Assigned later
    fn.defined.block = block;
    fn.code = code;
    fn.is_intrinsic = false;
    fn.return_vtype = calculate_return_vtype_for_fn(&fn, returns);
    
    array_add(&yov->functions, fn);
}

void define_intrinsic_function(CodeLocation code, IntrinsicFunction* callback, String identifier, Array<ObjectDefinition> parameters, Array<ObjectDefinition> returns)
{
    FunctionDefinition fn{};
    fn.identifier = identifier;
    fn.parameters = array_copy(yov->static_arena, parameters);
    fn.returns = array_copy(yov->static_arena, returns);
    fn.defined = {};
    fn.code = code;
    fn.intrinsic.fn = callback;
    fn.is_intrinsic = true;
    fn.return_vtype = calculate_return_vtype_for_fn(&fn, returns);
    
    array_add(&yov->functions, fn);
}

void define_global(ObjectDefinition def)
{
    def.name = string_copy(yov->static_arena, def.name);
    array_add(&yov->globals, def);
}

FunctionDefinition* find_function(String identifier)
{
    for (auto it = pooled_array_make_iterator(&yov->functions); it.valid; ++it) {
        FunctionDefinition* fn = it.value;
        if (string_equals(fn->identifier, identifier)) return fn;
    }
    return NULL;
}

ObjectDefinition* find_global(String identifier)
{
    for (auto it = pooled_array_make_iterator(&yov->globals); it.valid; ++it) {
        ObjectDefinition* def = it.value;
        if (string_equals(def->name, identifier)) return def;
    }
    return NULL;
}

ArgDefinition* find_arg_definition_by_name(String name)
{
    for (auto it = pooled_array_make_iterator(&yov->arg_definitions); it.valid; ++it) {
        ArgDefinition* def = it.value;
        if (string_equals(def->name, name)) return def;
    }
    return NULL;
}

b32 definition_exists(String identifier)
{
    if (find_function(identifier) != NULL) return true;
    if (vtype_from_name(identifier)->ID != VTypeID_Unknown) return true;
    return false;
}

ExpresionContext ExpresionContext_from_void() {
    ExpresionContext ctx{};
    ctx.vtype = void_vtype;
    ctx.allow_tuple = true;
    return ctx;
}

ExpresionContext ExpresionContext_from_inference() {
    ExpresionContext ctx{};
    ctx.vtype = VType_Any;
    ctx.allow_tuple = true;
    return ctx;
}

ExpresionContext ExpresionContext_from_vtype(VariableType* vtype, b32 allow_tuple) {
    ExpresionContext ctx{};
    ctx.vtype = vtype;
    ctx.allow_tuple = allow_tuple;
    return ctx;
}

Value value_none() {
    Value v{};
    v.vtype = void_vtype;
    v.register_index = -1;
    return v;
}

Value value_from_ir_object(IR_Object* object) {
    return value_from_register(object->register_index, object->vtype, true);
}

Value value_from_register(i32 index, VariableType* vtype, b32 is_lvalue) {
    Value v{};
    v.vtype = vtype;
    v.register_index = index;
    v.kind = is_lvalue ? ValueKind_LValue : ValueKind_Register;
    return v;
}

Value value_from_reference(Value value) {
    assert(value.kind == ValueKind_LValue || value.kind == ValueKind_Register);
    value.take_reference = true;
    return value;
}

Value value_from_int(i64 value) {
    Value v{};
    v.vtype = VType_Int;
    v.kind = ValueKind_Literal;
    v.literal_int = value;
    return v;
}

Value value_from_enum(VariableType* vtype, i64 value) {
    Value v{};
    v.vtype = vtype;
    v.kind = ValueKind_Literal;
    v.literal_int = value;
    return v;
}

Value value_from_bool(b32 value) {
    Value v{};
    v.vtype = VType_Bool;
    v.kind = ValueKind_Literal;
    v.literal_bool = value;
    return v;
}

Value value_from_string(Arena* arena, String value) {
    Value v{};
    v.vtype = VType_String;
    v.kind = ValueKind_Literal;
    v.literal_string = string_copy(arena, value);
    return v;
}

Value value_from_string_array(Arena* arena, Array<Value> values)
{
    SCRATCH(arena);
    
    b32 is_compiletime = true;
    
    foreach(i, values.count) {
        if (values[i].vtype->ID != VTypeID_String || !value_is_compiletime(values[i])) {
            is_compiletime = false;
            break;
        }
    }
    
    if (is_compiletime)
    {
        StringBuilder builder = string_builder_make(scratch.arena);
        foreach(i, values.count) {
            String str;
            ct_string_from_value(values[i], &str);
            append(&builder, str);
        }
        
        return value_from_string(arena, string_from_builder(scratch.arena, &builder));
    }
    else
    {
        Value v{};
        v.vtype = VType_String;
        v.kind = ValueKind_Composition;
        v.composition_string = array_copy(arena, values);
        return v;
    }
}

Value value_from_type(VariableType* type) {
    Value v{};
    v.vtype = VType_Type;
    v.kind = ValueKind_Literal;
    v.literal_type = type;
    return v;
}

Value value_from_array(Arena* arena, VariableType* array_vtype, Array<Value> elements)
{
    assert(array_vtype->kind == VariableKind_Array);
    Value v{};
    v.vtype = array_vtype;
    v.kind = ValueKind_Literal;
    v.literal_array.values = array_copy(arena, elements);
    v.literal_array.is_empty = false;
    return v;
}

Value value_from_empty_array(Arena* arena, VariableType* base_vtype, Array<Value> dimensions)
{
    assert(base_vtype->kind != VariableKind_Array);
    Value v{};
    v.vtype = vtype_from_dimension(base_vtype, dimensions.count);
    v.kind = ValueKind_Literal;
    v.literal_array.values = array_copy(arena, dimensions);
    v.literal_array.is_empty = true;
    return v;
}

Value value_from_default(VariableType* vtype)
{
    Value v{};
    v.vtype = vtype;
    v.kind = ValueKind_Default;
    return v;
}

Value value_from_constant(Arena* arena, VariableType* vtype, String identifier)
{
    Value v{};
    v.vtype = vtype;
    v.kind = ValueKind_Constant;
    v.constant_identifier = string_copy(arena, identifier);
    return v;
}

Value value_from_string_expression(Arena* arena, String str, VariableType* vtype)
{
    SCRATCH(arena);
    if (str.size <= 0) return value_none();
    // TODO(Jose): if (string_equals(str, "null")) return value_null();
    
    if (vtype->ID == VTypeID_Int) {
        i64 value;
        if (!i64_from_string(str, &value)) return value_none();
        return value_from_int(value);
    }
    
    if (vtype->ID == VTypeID_Bool) {
        if (string_equals(str, "true")) return value_from_bool(true);
        if (string_equals(str, "false")) return value_from_bool(false);
        if (string_equals(str, "1")) return value_from_bool(true);
        if (string_equals(str, "0")) return value_from_bool(false);
        return value_none();
    }
    
    if (vtype->ID == VTypeID_String) {
        return value_from_string(arena, str);
    }
    
    if (vtype->kind == VariableKind_Enum)
    {
        u64 start_name = 0;
        if (str[0] == '.') {
            start_name = 1;
        }
        else if (string_starts(str, string_format(scratch.arena, "%S.", vtype->name))) {
            start_name = vtype->name.size + 1;
        }
        
        String enum_name = string_substring(str, start_name, str.size - start_name);
        foreach(i, vtype->_enum.names.count) {
            if (string_equals(vtype->_enum.names[i], enum_name)) return value_from_enum(vtype, i);
        }
        return value_none();
    }
    
    return value_none();
}

String string_from_value(Arena* arena, Value value, b32 raw)
{
    SCRATCH(arena);
    
    if (value.kind == ValueKind_None) return "E";
    
    if (value.kind == ValueKind_Literal) {
        if (value.vtype->ID == VTypeID_Int) return string_format(arena, "%l", value.literal_int);
        if (value.vtype->ID == VTypeID_Bool) return value.literal_bool ? "true" : "false";
        if (value.vtype->ID == VTypeID_String) {
            if (raw) return value.literal_string;
            String escape = escape_string_from_raw_string(scratch.arena, value.literal_string);
            return string_format(arena, "\"%S\"", escape);
        }
        if (value.vtype == VType_Type) return value.literal_type->name;
        if (value.vtype->kind == VariableKind_Enum) {
            i32 index = (i32)value.literal_int;
            if (index < 0 || index >= value.vtype->_enum.names.count) return "?";
            return value.vtype->_enum.names[index];
        }
        if (value.vtype->kind == VariableKind_Array)
        {
            Array<Value> values = value.literal_array.values;
            b32 is_empty = value.literal_array.is_empty;
            if (values.count == 0) return "{ }";
            
            StringBuilder builder = string_builder_make(scratch.arena);
            
            if (is_empty)
            {
                append(&builder, "[");
                foreach(i, values.count) {
                    append(&builder, string_from_value(scratch.arena, values[i], false));
                    if (i < values.count - 1) append(&builder, ", ");
                }
                appendf(&builder, "]->%S", value.vtype->child_base->name);
            }
            else
            {
                append(&builder, "{ ");
                foreach(i, values.count) {
                    append(&builder, string_from_value(scratch.arena, values[i], false));
                    if (i < values.count - 1) append(&builder, ", ");
                }
                append(&builder, " }");
            }
            
            return string_from_builder(arena, &builder);
        }
        invalid_codepath();
        return "";
    }
    
    if (value.kind == ValueKind_Composition)
    {
        if (value.vtype->ID == VTypeID_String)
        {
            Array<Value> values = value.composition_string;
            StringBuilder builder = string_builder_make(scratch.arena);
            foreach(i, values.count) {
                String src = string_from_value(scratch.arena, values[i]);
                appendf(&builder, "%S", src);
                if (i < values.count - 1) append(&builder, " + ");
            }
            return string_from_builder(arena, &builder);
        }
    }
    
    if (value.kind == ValueKind_Constant)
    {
        return string_format(arena, "const(%S)", value.constant_identifier);
    }
    
    if (value.take_reference) {
        SCRATCH(arena);
        value.take_reference = false;
        return string_format(arena, "&%S", string_from_value(scratch.arena, value, raw));
    }
    
    if (value.kind == ValueKind_Default) {
        return string_format(arena, "%S()", value.vtype->name);
    }
    
    if (value.kind == ValueKind_Register || value.kind == ValueKind_LValue) {
        return string_from_register(arena, value.register_index);
    }
    
    invalid_codepath();
    return "";
}

b32 string_from_ct_value(Arena* arena, Value value, String* str)
{
    *str = {};
    
    if (value.vtype->ID == VTypeID_String) {
        return ct_string_from_value(value, str);
    }
    
    if (value.vtype->ID == VTypeID_Bool) {
        b32 b;
        b32 res = ct_bool_from_value(value, &b);
        *str = b ? "true" : "false";
        return res;
    }
    
    if (value.vtype->ID == VTypeID_Int) {
        i64 i;
        b32 res = ct_int_from_value(value, &i);
        *str = string_format(arena, "%l", i);
        return res;
    }
    
    return false;
}

b32 ct_string_from_value(Value value, String* str)
{
    *str = {};
    
    if (value.vtype->ID == VTypeID_String)
    {
        if (value.kind == ValueKind_Literal) {
            *str = value.literal_string;
            return true;
        }
        if (value.kind == ValueKind_Default) return true;
        if (value.kind == ValueKind_Constant)
        {
            ObjectDefinition* def = find_global(value.constant_identifier);
            if (def != NULL) {
                return ct_string_from_value(def->ir.value, str);
            }
        }
    }
    
    invalid_codepath();
    return false;
}

b32 ct_bool_from_value(Value value, b32* b)
{
    *b = false;
    
    if (value.vtype->ID == VTypeID_Bool)
    {
        if (value.kind == ValueKind_Literal) {
            *b = value.literal_bool;
            return true;
        }
        if (value.kind == ValueKind_Default) return true;
        if (value.kind == ValueKind_Constant)
        {
            ObjectDefinition* def = find_global(value.constant_identifier);
            if (def != NULL) {
                return ct_bool_from_value(def->ir.value, b);
            }
        }
    }
    
    return false;
}

b32 ct_int_from_value(Value value, i64* v)
{
    *v = 0;
    
    if (value.vtype->ID == VTypeID_Int)
    {
        if (value.kind == ValueKind_Literal) {
            *v = value.literal_int;
            return true;
        }
        if (value.kind == ValueKind_Default) return true;
        if (value.kind == ValueKind_Constant)
        {
            ObjectDefinition* def = find_global(value.constant_identifier);
            if (def != NULL) {
                return ct_int_from_value(def->ir.value, v);
            }
        }
    }
    
    return false;
}