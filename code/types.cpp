constexpr Object _make_object(VariableType* vtype) {
    Object obj{};
    obj.vtype = vtype;
    return obj;
}
constexpr VariableType _make_vtype(VTypeID ID, VariableType* child, const char* name, u32 name_size) {
    VariableType type{};
    type.ID = ID;
    type.name.size = name_size;
    type.name.data = (char*)name;
    type.kind = VariableKind_Unknown;
    type.child_next = child;
    type.child_base = child;
    return type;
}

read_only VariableType _nil_vtype = _make_vtype(VTypeID_Unknown, &_nil_vtype, "Unknown", sizeof("Unknown"));
read_only VariableType _void_vtype = _make_vtype(VTypeID_Void, &_nil_vtype, "void", sizeof("void"));

read_only Object _nil_obj = _make_object(&_nil_vtype);
read_only Object _null_obj = _make_object(&_void_vtype);

VariableType* nil_vtype = &_nil_vtype;
VariableType* void_vtype = &_void_vtype;

Object* nil_obj = &_nil_obj;
Object* null_obj = &_null_obj;

#include "autogenerated/core.h"

inline_fn void vtype_add_core(VariableKind kind, String name, u32 size, u64 assert_vtype) {
    VariableType* vtype = vtype_add(kind, name, size, nil_vtype, nil_vtype);
    assert(vtype->ID == assert_vtype);
}

void types_initialize(b32 import_core)
{
    yov->vtype_table = pooled_array_make<VariableType>(yov->static_arena, 32);
    yov->functions = pooled_array_make<FunctionDefinition>(yov->static_arena, 32);
    yov->arg_definitions = pooled_array_make<ArgDefinition>(yov->static_arena, 32);
    yov->globals = pooled_array_make<ObjectDefinition>(yov->static_arena, 32);
    
    vtype_add_core(VariableKind_Any, "Any", sizeof(Object*), VTypeID_Any);
    vtype_add_core(VariableKind_Primitive, "Int", sizeof(i64), VTypeID_Int);
    vtype_add_core(VariableKind_Primitive, "Bool", sizeof(b32), VTypeID_Bool);
    vtype_add_core(VariableKind_Primitive, "String", sizeof(ObjectData_String), VTypeID_String);
    
    {
        VariableTypeChild string_properties[] = {
            VariableTypeChild{ false, STR("size"), 0, VType_Int }
        };
        
        VariableTypeChild array_properties[] = {
            VariableTypeChild{ false, STR("count"), 0, VType_Int }
        };
        
        VariableTypeChild enum_properties[] = {
            VariableTypeChild{ false, STR("index"), 0, VType_Int },
            VariableTypeChild{ false, STR("value"), 1, VType_Int },
            VariableTypeChild{ false, STR("name"), 2, VType_String }
        };
        
        yov->string_properties = array_copy(yov->static_arena, array_make(string_properties, countof(string_properties)));
        yov->array_properties = array_copy(yov->static_arena, array_make(array_properties, countof(array_properties)));
        yov->enum_properties = array_copy(yov->static_arena, array_make(enum_properties, countof(enum_properties)));
    }
    
    if (import_core) define_core();
}

VariableType* vtype_add(VariableKind kind, String name, u32 size, VariableType* child_next, VariableType* child_base)
{
    u64 ID = yov->vtype_table.count + 1;
    VariableType* type = array_add(&yov->vtype_table);
    type->ID = ID;
    type->size = size;
    type->kind = kind;
    type->name = string_copy(yov->static_arena, name);
    type->child_base = child_base;
    type->child_next = child_next;
    
    return type;
}

VariableType* vtype_get(VTypeID ID) {
    if (ID == VTypeID_Void) return void_vtype;
    u32 index = (u32)ID - 1;
    if (index < 0 || index >= yov->vtype_table.count) return nil_vtype;
    return &yov->vtype_table[index];
}

VariableType* vtype_from_dimension(VariableType* element, u32 dimension)
{
    SCRATCH();
    if (dimension == 0) return element;
    
    for (auto it = pooled_array_make_iterator(&yov->vtype_table); it.valid; ++it) {
        VariableType* type = it.value;
        if (type->kind != VariableKind_Array) continue;
        if (type->array_dimensions != dimension) continue;
        if (type->child_base->ID != element->ID) continue;
        return type;
    }
    
    VariableType* child_base = element;
    VariableType* child_next = (dimension == 1) ? child_base : vtype_from_dimension(element, dimension - 1);
    String name = string_format(scratch.arena, "%S[]", child_next->name);
    
    VariableType* type = vtype_add(VariableKind_Array, name, sizeof(ObjectData_Array), child_next, child_base);
    type->array_dimensions = dimension;
    
    return type;
}

VariableType* vtype_from_reference(VariableType* base_type)
{
    if (base_type->kind == VariableKind_Reference) {
        invalid_codepath();
        return nil_vtype;
    }
    
    for (auto it = pooled_array_make_iterator(&yov->vtype_table); it.valid; ++it) {
        VariableType* type = it.value;
        if (type->kind != VariableKind_Reference) continue;
        if (type->child_base != base_type) continue;
        if (type->child_next != base_type) continue;
        return type;
    }
    
    SCRATCH();
    String name = string_format(scratch.arena, "%S&", base_type->name);
    return vtype_add(VariableKind_Reference, name, sizeof(ObjectData_Ref), base_type, base_type);
}

b32 vtype_is_enum(VariableType* vtype) { return vtype->kind == VariableKind_Enum; }
b32 vtype_is_array(VariableType* vtype) { return vtype->kind == VariableKind_Array; }
b32 vtype_is_struct(VariableType* vtype) { return vtype->kind == VariableKind_Struct; }
b32 vtype_is_tuple(VariableType* vtype) { return vtype_is_struct(vtype) && vtype->_struct.is_tuple; }
b32 vtype_is_reference(VariableType* vtype) { return vtype->kind == VariableKind_Reference; }

b32 vtype_needs_internal_release(VariableType* vtype)
{
    if (vtype_is_array(vtype)) return true;
    if (vtype_is_reference(vtype)) return true;
    if (vtype->ID == VTypeID_String) return true;
    
    if (vtype_is_struct(vtype)) {
        return vtype->_struct.needs_internal_release;
    }
    
    return false;
}

VariableType* vtype_from_name(String name)
{
    u32 dimensions = 0;
    while (name.size > 2 && name[name.size - 1] == ']' && name[name.size - 2] == '[') {
        name = string_substring(name, 0, name.size - 2);
        dimensions++;
    }
    
    for (auto it = pooled_array_make_iterator(&yov->vtype_table); it.valid; ++it) {
        if (string_equals(it.value->name, name)) {
            return vtype_from_dimension(it.value, dimensions);
        }
    }
    return nil_vtype;
}

VariableType* vtype_get_child_at(VariableType* vtype, u32 index, b32 is_member)
{
    if (is_member)
    {
        if (vtype->kind == VariableKind_Array) {
            return vtype->child_next;
        }
        else if (vtype->kind == VariableKind_Struct) {
            Array<VariableType*> vtypes = vtype->_struct.vtypes;
            if (index >= vtypes.count) return nil_vtype;
            return vtypes[index];
        }
    }
    else
    {
        // TODO(Jose): 
        invalid_codepath();
    }
    
    return nil_vtype;
}

VariableTypeChild vtype_get_child(VariableType* vtype, String name)
{
    VariableTypeChild info = vtype_get_member(vtype, name);
    if (info.index >= 0) return info;
    return vtype_get_property(vtype, name);
}

VariableTypeChild vtype_get_member(VariableType* vtype, String member)
{
    if (vtype->kind == VariableKind_Struct) {
        Array<String> names = vtype->_struct.names;
        foreach(i, names.count) {
            if (string_equals(names[i], member)) {
                return { true, names[i], (i32)i, vtype->_struct.vtypes[i] };
            }
        }
    }
    
    return { true, "", -1, nil_vtype };
}

VariableTypeChild vtype_get_property(VariableType* vtype, String property)
{
    Array<VariableTypeChild> props = vtype_get_properties(vtype);
    foreach(i, props.count) {
        if (string_equals(props[i].name, property)) return props[i];
    }
    return { false, "", -1, nil_vtype };
}

Array<VariableTypeChild> vtype_get_properties(VariableType* vtype)
{
    if (vtype->ID == VTypeID_String) return yov->string_properties;
    if (vtype->kind == VariableKind_Array) return yov->array_properties;
    if (vtype->kind == VariableKind_Enum) return yov->enum_properties;
    return {};
}

Array<VariableType*> vtype_unpack(Arena* arena, VariableType* vtype)
{
    if (!vtype_is_struct(vtype)) {
        Array<VariableType*> vtypes = array_make<VariableType*>(arena, 1);
        vtypes[0] = vtype;
        return vtypes;
    }
    
    return vtype->_struct.vtypes;
}

VariableType* vtype_from_node(OpNode_ObjectType* node)
{
    if (node->name.size == 0) return void_vtype;
    VariableType* vtype = vtype_from_name(node->name);
    vtype = vtype_from_dimension(vtype, node->array_dimensions);
    if (vtype == nil_vtype) report_object_type_not_found(node->code, node->name);
    if (node->is_reference) vtype = vtype_from_reference(vtype);
    return vtype;
}

VariableType* vtype_from_binary_operation(VariableType* left, VariableType* right, BinaryOperator op)
{
    if (left->kind == VariableKind_Reference && left == right)
    {
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->ID == VTypeID_Int && right->ID == VTypeID_Int) {
        if (binary_operator_is_arithmetic(op)) return VType_Int;
        
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
        if (op == BinaryOperator_LessThan) return VType_Bool;
        if (op == BinaryOperator_LessEqualsThan) return VType_Bool;
        if (op == BinaryOperator_GreaterThan) return VType_Bool;
        if (op == BinaryOperator_GreaterEqualsThan) return VType_Bool;
    }
    
    if (left->ID == VTypeID_Bool && right->ID == VTypeID_Bool) {
        if (op == BinaryOperator_LogicalOr) return VType_Bool;
        if (op == BinaryOperator_LogicalAnd) return VType_Bool;
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->ID == VTypeID_String && right->ID == VTypeID_String)
    {
        if (op == BinaryOperator_Addition) return VType_String;
        if (op == BinaryOperator_Division) return VType_String;
        if (op == BinaryOperator_Equals) return VType_Bool;
        if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->ID == VType_Type->ID && right->ID == VType_Type->ID)
    {
        if (op == BinaryOperator_Equals) return VType_Bool;
        else if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if ((left->ID == VTypeID_String && right->ID == VTypeID_Int) || (left->ID == VTypeID_Int && right->ID == VTypeID_String))
    {
        if (op == BinaryOperator_Addition) return VType_String;
    }
    
    if (left->kind == VariableKind_Enum && right->kind == VariableKind_Enum) {
        if (op == BinaryOperator_Equals) return VType_Bool;
        else if (op == BinaryOperator_NotEquals) return VType_Bool;
    }
    
    if (left->child_next->ID == right->child_next->ID && left->kind == VariableKind_Array && right->kind == VariableKind_Array) {
        if (op == BinaryOperator_Addition) return left;
    }
    
    if ((left->kind == VariableKind_Array && right->kind != VariableKind_Array) || (left->kind != VariableKind_Array && right->kind == VariableKind_Array))
    {
        VariableType* array_type = (left->kind == VariableKind_Array) ? left : right;
        VariableType* element_type = (left->kind == VariableKind_Array) ? right : left;
        
        if (array_type->child_next->ID == element_type->ID) {
            if (op == BinaryOperator_Addition) return array_type;
        }
    }
    
    return nil_vtype;
}

VariableType* vtype_from_sign_operation(VariableType* src, BinaryOperator op)
{
    if (src->ID == VTypeID_Int) {
        if (op == BinaryOperator_Addition) return VType_Int;
        if (op == BinaryOperator_Substraction) return VType_Int;
    }
    
    if (src->ID == VTypeID_Bool) {
        if (op == BinaryOperator_LogicalNot) return VType_Bool;
    }
    
    return nil_vtype;
}

VariableType* define_enum(String name, Array<String> names, Array<i64> values)
{
    SCRATCH();
    
    if (values.count == 0) {
        values = array_make<i64>(scratch.arena, names.count);
        foreach(i, values.count) values[i] = i;
    }
    
    names = array_copy(yov->static_arena, names);
    values = array_copy(yov->static_arena, values);
    
    VariableType* t = vtype_add(VariableKind_Enum, name, sizeof(i64), nil_vtype, nil_vtype);
    t->_enum.names = names;
    t->_enum.values = values;
    assert(names.count == values.count);
    
    return t;
}

VariableType* vtype_define_struct(String name, OpNode_StructDefinition* node, b32 is_tuple)
{
    VariableType* t = vtype_add(VariableKind_Struct, name, 0, nil_vtype, nil_vtype);
    t->_struct.node = node;
    t->_struct.is_tuple = is_tuple;
    return t;
}

b32 vtype_init_struct(VariableType* vtype, Array<ObjectDefinition> members)
{
    if (vtype->size != 0) {
        invalid_codepath();
        return false;
    }
    
    SCRATCH();
    PooledArray<String> names = pooled_array_make<String>(scratch.arena, members.count);
    PooledArray<VariableType*> vtypes = pooled_array_make<VariableType*>(scratch.arena, members.count);
    PooledArray<u32> offsets = pooled_array_make<u32>(scratch.arena, members.count);
    PooledArray<IR> irs = pooled_array_make<IR>(scratch.arena, members.count);
    
    u32 size = 0;
    b32 needs_internal_release = false;
    
    foreach(i, members.count)
    {
        ObjectDefinition member = members[i];
        
        array_add(&names, member.name);
        array_add(&vtypes, member.vtype);
        array_add(&offsets, size);
        array_add(&irs, member.ir);
        
        if (member.vtype == nil_vtype) return false;
        if (member.vtype == void_vtype) return false;
        
        size += member.vtype->size;
        needs_internal_release |= vtype_needs_internal_release(member.vtype);
    }
    
#if DEV
    assert(names.count == vtypes.count && names.count == offsets.count && names.count == irs.count);
#endif
    
    vtype->size = size;
    vtype->_struct.needs_internal_release = needs_internal_release;
    vtype->_struct.names = array_from_pooled_array(yov->static_arena, names);
    vtype->_struct.vtypes = array_from_pooled_array(yov->static_arena, vtypes);
    vtype->_struct.offsets = array_from_pooled_array(yov->static_arena, offsets);
    vtype->_struct.irs = array_from_pooled_array(yov->static_arena, irs);
    return true;
}

ObjectDefinition define_arg(String identifier, String name, Value value, b32 required, String description)
{
    ArgDefinition arg{};
    arg.identifier = identifier;
    arg.name = name;
    arg.vtype = value.vtype;
    arg.required = required;
    arg.description = description;
    
    array_add(&yov->arg_definitions, arg);
    
    IR ir = ir_generate_from_value(value);
    ObjectDefinition def = obj_def_make(identifier, value.vtype, true, ir);
    define_global(def);
    return def;
}

internal_fn VariableType* calculate_return_vtype_for_fn(FunctionDefinition* fn, Array<ObjectDefinition> returns)
{
    SCRATCH();
    
    if (returns.count == 0) return void_vtype;
    
    if (returns.count == 1 && string_equals(returns[0].name, "return")) {
        return returns[0].vtype;
    }
    
    VariableType* vtype = vtype_define_struct(string_format(scratch.arena, "%S_return", fn->identifier), NULL, true);
    vtype_init_struct(vtype, returns);
    return vtype;
}

void define_function(CodeLocation code, String identifier, Array<ObjectDefinition> parameters, Array<ObjectDefinition> returns, OpNode_Block* block)
{
    FunctionDefinition fn{};
    fn.identifier = identifier;
    fn.parameters = array_copy(yov->static_arena, parameters);
    fn.returns = array_copy(yov->static_arena, returns);
    fn.defined.ir = {}; // Assigned later
    fn.defined.block = block;
    fn.code = code;
    fn.is_intrinsic = false;
    fn.return_vtype = calculate_return_vtype_for_fn(&fn, returns);
    
    array_add(&yov->functions, fn);
}

void define_intrinsic_function(CodeLocation code, IntrinsicFunction* callback, String identifier, Array<ObjectDefinition> parameters, Array<ObjectDefinition> returns)
{
    FunctionDefinition fn{};
    fn.identifier = identifier;
    fn.parameters = array_copy(yov->static_arena, parameters);
    fn.returns = array_copy(yov->static_arena, returns);
    fn.defined = {};
    fn.code = code;
    fn.intrinsic.fn = callback;
    fn.is_intrinsic = true;
    fn.return_vtype = calculate_return_vtype_for_fn(&fn, returns);
    
    array_add(&yov->functions, fn);
}

void define_global(ObjectDefinition def)
{
    def.name = string_copy(yov->static_arena, def.name);
    array_add(&yov->globals, def);
}

FunctionDefinition* find_function(String identifier)
{
    for (auto it = pooled_array_make_iterator(&yov->functions); it.valid; ++it) {
        FunctionDefinition* fn = it.value;
        if (string_equals(fn->identifier, identifier)) return fn;
    }
    return NULL;
}

ObjectDefinition* find_global(String identifier)
{
    for (auto it = pooled_array_make_iterator(&yov->globals); it.valid; ++it) {
        ObjectDefinition* def = it.value;
        if (string_equals(def->name, identifier)) return def;
    }
    return NULL;
}

ArgDefinition* find_arg_definition_by_name(String name)
{
    for (auto it = pooled_array_make_iterator(&yov->arg_definitions); it.valid; ++it) {
        ArgDefinition* def = it.value;
        if (string_equals(def->name, name)) return def;
    }
    return NULL;
}

b32 definition_exists(String identifier)
{
    if (find_function(identifier) != NULL) return true;
    if (vtype_from_name(identifier)->ID != VTypeID_Unknown) return true;
    return false;
}

ExpresionContext ExpresionContext_from_void() {
    ExpresionContext ctx{};
    ctx.vtype = void_vtype;
    ctx.allow_tuple = true;
    return ctx;
}

ExpresionContext ExpresionContext_from_inference() {
    ExpresionContext ctx{};
    ctx.vtype = VType_Any;
    ctx.allow_tuple = true;
    return ctx;
}

ExpresionContext ExpresionContext_from_vtype(VariableType* vtype, b32 allow_tuple) {
    ExpresionContext ctx{};
    ctx.vtype = vtype;
    ctx.allow_tuple = allow_tuple;
    return ctx;
}

b32 value_is_compiletime(Value value)
{
    if (value.kind == ValueKind_Array)
    {
        foreach(i, value.array.values.count) {
            if (!value_is_compiletime(value.array.values[i])) return false;
        }
        return true;
    }
    
    return value.kind == ValueKind_Literal || value.kind == ValueKind_Default || value.kind == ValueKind_Constant;
}

b32 value_is_rvalue(Value value) { return value.kind != ValueKind_None && value.kind != ValueKind_LValue; }

b32 value_equals(Value v0, Value v1)
{
    if (v0.kind != v1.kind) return false;
    
    if (v0.kind == ValueKind_LValue || v0.kind == ValueKind_Register) {
        return v0.reg.index == v1.reg.index && v0.reg.reference_op == v1.reg.reference_op;
    }
    
    return false;
}

Value value_none() {
    Value v{};
    v.vtype = void_vtype;
    v.reg.index = -1;
    return v;
}

Value value_from_ir_object(IR_Object* object) {
    return value_from_register(object->register_index, object->vtype, true);
}

Value value_from_register(i32 index, VariableType* vtype, b32 is_lvalue) {
    Value v{};
    v.vtype = vtype;
    v.reg.index = index;
    v.reg.reference_op = 0;
    v.kind = is_lvalue ? ValueKind_LValue : ValueKind_Register;
    return v;
}

Value value_from_reference(Value value)
{
    assert(value.kind == ValueKind_LValue || value.kind == ValueKind_Register);
    assert(value.reg.reference_op <= 0);
    
    Value v{};
    v.vtype = vtype_from_reference(value.vtype);
    v.reg.index = value.reg.index;
    v.reg.reference_op = value.reg.reference_op + 1;
    v.kind = value.kind;
    return v;
}

Value value_from_dereference(Value value)
{
    assert(value.kind == ValueKind_LValue || value.kind == ValueKind_Register);
    assert(value.vtype->kind == VariableKind_Reference);
    
    Value v{};
    v.vtype = value.vtype->child_next;
    v.reg.index = value.reg.index;
    v.reg.reference_op = value.reg.reference_op - 1;
    v.kind = value.kind;
    return v;
}

Value value_from_int(i64 value) {
    Value v{};
    v.vtype = VType_Int;
    v.kind = ValueKind_Literal;
    v.literal_int = value;
    return v;
}

Value value_from_enum(VariableType* vtype, i64 value) {
    Value v{};
    v.vtype = vtype;
    v.kind = ValueKind_Literal;
    v.literal_int = value;
    return v;
}

Value value_from_bool(b32 value) {
    Value v{};
    v.vtype = VType_Bool;
    v.kind = ValueKind_Literal;
    v.literal_bool = value;
    return v;
}

Value value_from_string(Arena* arena, String value) {
    Value v{};
    v.vtype = VType_String;
    v.kind = ValueKind_Literal;
    v.literal_string = string_copy(arena, value);
    return v;
}

Value value_from_string_array(Interpreter* inter, Arena* arena, Array<Value> values)
{
    SCRATCH(arena);
    
    b32 is_compiletime = true;
    
    foreach(i, values.count) {
        if (values[i].vtype->ID != VTypeID_String || !value_is_compiletime(values[i])) {
            is_compiletime = false;
            break;
        }
    }
    
    if (is_compiletime)
    {
        StringBuilder builder = string_builder_make(scratch.arena);
        foreach(i, values.count) {
            Reference ref = ref_from_value(inter, inter->global_scope, values[i]);
            String str = string_from_ref(scratch.arena, inter, ref, true);
            append(&builder, str);
        }
        
        return value_from_string(arena, string_from_builder(scratch.arena, &builder));
    }
    else
    {
        Value v{};
        v.vtype = VType_String;
        v.kind = ValueKind_Composition;
        v.composition_string = array_copy(arena, values);
        return v;
    }
}

Value value_from_type(VariableType* type) {
    Value v{};
    v.vtype = VType_Type;
    v.kind = ValueKind_Literal;
    v.literal_type = type;
    return v;
}

Value value_from_array(Arena* arena, VariableType* array_vtype, Array<Value> elements)
{
    assert(array_vtype->kind == VariableKind_Array);
    Value v{};
    v.vtype = array_vtype;
    v.kind = ValueKind_Array;
    v.array.values = array_copy(arena, elements);
    v.array.is_empty = false;
    return v;
}

Value value_from_empty_array(Arena* arena, VariableType* base_vtype, Array<Value> dimensions)
{
    assert(base_vtype->kind != VariableKind_Array);
    Value v{};
    v.vtype = vtype_from_dimension(base_vtype, dimensions.count);
    v.kind = ValueKind_Array;
    v.array.values = array_copy(arena, dimensions);
    v.array.is_empty = true;
    return v;
}

Value value_from_default(VariableType* vtype)
{
    Value v{};
    v.vtype = vtype;
    v.kind = ValueKind_Default;
    return v;
}

Value value_from_constant(Arena* arena, VariableType* vtype, String identifier)
{
    Value v{};
    v.vtype = vtype;
    v.kind = ValueKind_Constant;
    v.constant_identifier = string_copy(arena, identifier);
    return v;
}

Value value_from_string_expression(Arena* arena, String str, VariableType* vtype)
{
    SCRATCH(arena);
    if (str.size <= 0) return value_none();
    // TODO(Jose): if (string_equals(str, "null")) return value_null();
    
    if (vtype->ID == VTypeID_Int) {
        i64 value;
        if (!i64_from_string(str, &value)) return value_none();
        return value_from_int(value);
    }
    
    if (vtype->ID == VTypeID_Bool) {
        if (string_equals(str, "true")) return value_from_bool(true);
        if (string_equals(str, "false")) return value_from_bool(false);
        if (string_equals(str, "1")) return value_from_bool(true);
        if (string_equals(str, "0")) return value_from_bool(false);
        return value_none();
    }
    
    if (vtype->ID == VTypeID_String) {
        return value_from_string(arena, str);
    }
    
    if (vtype->kind == VariableKind_Enum)
    {
        u64 start_name = 0;
        if (str[0] == '.') {
            start_name = 1;
        }
        else if (string_starts(str, string_format(scratch.arena, "%S.", vtype->name))) {
            start_name = vtype->name.size + 1;
        }
        
        String enum_name = string_substring(str, start_name, str.size - start_name);
        foreach(i, vtype->_enum.names.count) {
            if (string_equals(vtype->_enum.names[i], enum_name)) return value_from_enum(vtype, i);
        }
        return value_none();
    }
    
    return value_none();
}

String string_from_value(Arena* arena, Value value, b32 raw)
{
    SCRATCH(arena);
    
    if (value.kind == ValueKind_None) return "E";
    
    if (value.kind == ValueKind_Literal) {
        if (value.vtype->ID == VTypeID_Int) return string_format(arena, "%l", value.literal_int);
        if (value.vtype->ID == VTypeID_Bool) return value.literal_bool ? "true" : "false";
        if (value.vtype->ID == VTypeID_String) {
            if (raw) return value.literal_string;
            String escape = escape_string_from_raw_string(scratch.arena, value.literal_string);
            return string_format(arena, "\"%S\"", escape);
        }
        if (value.vtype == VType_Type) return value.literal_type->name;
        if (value.vtype->kind == VariableKind_Enum) {
            i32 index = (i32)value.literal_int;
            if (index < 0 || index >= value.vtype->_enum.names.count) return "?";
            return value.vtype->_enum.names[index];
        }
        invalid_codepath();
        return "";
    }
    
    if (value.kind == ValueKind_Array)
    {
        Array<Value> values = value.array.values;
        b32 is_empty = value.array.is_empty;
        if (values.count == 0) return "{ }";
        
        StringBuilder builder = string_builder_make(scratch.arena);
        
        if (is_empty)
        {
            append(&builder, "[");
            foreach(i, values.count) {
                append(&builder, string_from_value(scratch.arena, values[i], false));
                if (i < values.count - 1) append(&builder, ", ");
            }
            appendf(&builder, "]->%S", value.vtype->child_base->name);
        }
        else
        {
            append(&builder, "{ ");
            foreach(i, values.count) {
                append(&builder, string_from_value(scratch.arena, values[i], false));
                if (i < values.count - 1) append(&builder, ", ");
            }
            append(&builder, " }");
        }
        
        return string_from_builder(arena, &builder);
    }
    
    if (value.kind == ValueKind_Composition)
    {
        if (value.vtype->ID == VTypeID_String)
        {
            Array<Value> values = value.composition_string;
            StringBuilder builder = string_builder_make(scratch.arena);
            foreach(i, values.count) {
                String src = string_from_value(scratch.arena, values[i]);
                appendf(&builder, "%S", src);
                if (i < values.count - 1) append(&builder, " + ");
            }
            return string_from_builder(arena, &builder);
        }
    }
    
    if (value.kind == ValueKind_Constant)
    {
        return string_format(arena, "const(%S)", value.constant_identifier);
    }
    
    if (value.kind == ValueKind_Default) {
        return string_format(arena, "%S()", value.vtype->name);
    }
    
    if (value.kind == ValueKind_Register || value.kind == ValueKind_LValue)
    {
        String ref_op = "";
        
        if (value.reg.reference_op != 0)
        {
            i32 op = value.reg.reference_op;
            
            while (op > 0) {
                ref_op = string_format(scratch.arena, "&%S", ref_op);
                op--;
            }
            
            while (op < 0) {
                ref_op = string_format(scratch.arena, "*%S", ref_op);
                op++;
            }
        }
        
        return string_format(arena, "%S%S", ref_op, string_from_register(scratch.arena, value.reg.index));
    }
    
    invalid_codepath();
    return "";
}
