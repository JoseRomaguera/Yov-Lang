#include "inc.h"

internal_fn void indent(StringBuilder* builder, u32 count) {
    foreach(i, count) append(builder, "    ");
}

void yov_transpile_core_definitions()
{
    String core_yov_path = path_append(yov->temp_arena, yov->caller_dir, "code/core.yov");
    String core_h_path = path_append(yov->temp_arena, yov->caller_dir, "code/autogenerated/core.h");
    
    i32 main_script_id = yov_import_script(core_yov_path);
    YovScript* main_script = yov_get_script(main_script_id);
    
    if (yov->error_count > 0) {
        yov_print_reports();
        os_console_wait();
        return;
    }
    
    String code = transpile_definitions(yov->temp_arena, (OpNode_Block*)main_script->ast);
    print_info(code);
    
    os_write_entire_file(core_h_path, { code.data, code.size });
}

String transpile_definitions(Arena* arena, OpNode_Block* ast)
{
    SCRATCH(arena);
    StringBuilder builder = string_builder_make(scratch.arena);
    
    appendf(&builder, "#pragma once\n\n");
    appendf(&builder, "internal_fn void define_core()\n");
    appendf(&builder, "{\n");
    
    foreach(i, ast->ops.count)
    {
        OpNode* node0 = ast->ops[i];
        
        if (node0->kind == OpKind_StructDefinition)
        {
            OpNode_StructDefinition* node = (OpNode_StructDefinition*)node0;
            String name = node->identifier;
            
            indent(&builder, 1); appendf(&builder, "// struct %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            u32 in = 2;
            
            indent(&builder, in); appendf(&builder, "ObjectDefinition m[%u];\n", node->members.count);
            foreach(i, node->members.count) {
                OpNode_ObjectDefinition* member = node->members[i];
                String obj = transpile_definition_for_object_definition_from_node(scratch.arena, member);
                indent(&builder, in); appendf(&builder, "m[%u] = %S;\n", i, obj);
            }
            indent(&builder, in); append(&builder, "Array<ObjectDefinition> members = array_make(m, countof(m));\n");
            
            indent(&builder, in); appendf(&builder, "define_struct(\"%S\", members);\n", name);
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        if (node0->kind == OpKind_EnumDefinition)
        {
            OpNode_EnumDefinition* node = (OpNode_EnumDefinition*)node0;
            String name = node->identifier;
            
            indent(&builder, 1); appendf(&builder, "// enum %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            u32 in = 2;
            
            indent(&builder, in); appendf(&builder, "String n[%u];\n", node->names.count);
            foreach(i, node->names.count) {
                indent(&builder, in); appendf(&builder, "n[%u] = \"%S\";\n", i, node->names[i]);
            }
            
            indent(&builder, in); append(&builder, "Array<String> names = array_make(n, countof(n));\n");
            indent(&builder, in); appendf(&builder, "define_enum(\"%S\", names, {});\n", name);
            
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        if (node0->kind == OpKind_FunctionDefinition)
        {
            OpNode_FunctionDefinition* node = (OpNode_FunctionDefinition*)node0;
            String name = node->identifier;
            
            u32 in = 2;
            
            indent(&builder, 1); appendf(&builder, "// function %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            indent(&builder, in); append(&builder, "Array<ObjectDefinition> parameters{};\n");
            indent(&builder, in); append(&builder, "Array<ObjectDefinition> returns{};\n");
            if (node->parameters.count) {
                indent(&builder, in); appendf(&builder, "ObjectDefinition p[%u];\n", node->parameters.count);
                foreach(i, node->parameters.count) {
                    OpNode_ObjectDefinition* parameter = node->parameters[i];
                    String obj = transpile_definition_for_object_definition_from_node(scratch.arena, parameter);
                    indent(&builder, in); appendf(&builder, "p[%u] = %S;\n", i, obj);
                }
                indent(&builder, in); append(&builder, "parameters = array_make(p, countof(p));\n");
            }
            
            if (node->returns.count) {
                indent(&builder, in); appendf(&builder, "ObjectDefinition r[%u];\n", node->returns.count);
                foreach(i, node->returns.count) {
                    
                    OpNode* node0 = node->returns[i];
                    
                    String obj = "?";
                    
                    if (node0->kind == OpKind_ObjectType) {
                        OpNode_ObjectType* type = (OpNode_ObjectType*)node0;
                        String type_name = transpile_definition_for_object_type(scratch.arena, type, NULL);
                        obj = transpile_definition_for_object_definition(scratch.arena, "return", type_name, type->is_reference);
                    }
                    else if (node0->kind == OpKind_ObjectDefinition) {
                        OpNode_ObjectDefinition* def = (OpNode_ObjectDefinition*)node0;
                        obj = transpile_definition_for_object_definition_from_node(scratch.arena, def);
                    }
                    
                    indent(&builder, in); appendf(&builder, "r[%u] = %S;\n", i, obj);
                }
                indent(&builder, in); append(&builder, "returns = array_make(r, countof(r));\n");
            }
            
            indent(&builder, in); appendf(&builder, "define_intrinsic_function({}, \"%S\", parameters, returns);\n", node->identifier);
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        if (node0->kind == OpKind_ObjectDefinition)
        {
            OpNode_ObjectDefinition* node = (OpNode_ObjectDefinition*)node0;
            if (!node->is_constant) continue;
            
            // TODO(Jose): Support multiple names
            String name = node->names[0];
            
            u32 in = 2;
            
            indent(&builder, 1); appendf(&builder, "// global %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            String def = transpile_definition_for_object_definition_from_node(scratch.arena, node);
            
            indent(&builder, in); appendf(&builder, "define_global(%S);\n", def);
            
            if (node->assignment->kind == OpKind_None) {}
            else if (node->assignment->kind == OpKind_FunctionCall) {}
            else {
                assert(0);
            }
            
            indent(&builder, 1); append(&builder, "}\n");
            continue;
        }
        
        assert(0);
    }
    
    appendf(&builder, "}\n");
    
    return string_from_builder(arena, &builder);
}

String transpile_definition_for_object_type(Arena* arena, OpNode_ObjectType* node, OpNode* assign_node)
{
    SCRATCH(arena);
    
    String name = node->name;
    
    if (node->name.size == 0 && assign_node != NULL) {
        if (assign_node->kind == OpKind_FunctionCall) name = ((OpNode_FunctionCall*)assign_node)->identifier;
    }
    
    String type = string_format(scratch.arena, "vtype_from_name(\"%S\")", name);
    if (node->array_dimensions) {
        type = string_format(scratch.arena, "vtype_from_dimension(%S, %u)", type, node->array_dimensions);
    }
    
    return string_copy(arena, type);
}

String transpile_definition_for_object_definition_from_node(Arena* arena, OpNode_ObjectDefinition* node)
{
    SCRATCH(arena);
    
    // TODO(Jose): Support multiple names
    String name = node->names[0];
    String type = transpile_definition_for_object_type(scratch.arena, node->type, node->assignment);
    String is_ref = node->type->is_reference ? "true" : "false";
    
    return string_format(arena, "obj_def_make(\"%S\", %S, %S)", name, type, is_ref);
}

String transpile_definition_for_object_definition(Arena* arena, String name, String type, b32 is_reference)
{
    String is_ref = is_reference ? "true" : "false";
    return string_format(arena, "obj_def_make(\"%S\", %S, %S)", name, type, is_ref);
}