#include "inc.h"

internal_fn void indent(StringBuilder* builder, u32 count) {
    foreach(i, count) append(builder, "    ");
}

void yov_transpile_core_definitions()
{
    String core_yov_path = path_append(yov->temp_arena, yov->caller_dir, STR("code/core.yov"));
    String core_h_path = path_append(yov->temp_arena, yov->caller_dir, STR("code/autogenerated/core.h"));
    
    i32 main_script_id = yov_import_script(core_yov_path);
    YovScript* main_script = yov_get_script(main_script_id);
    
    if (yov->error_count > 0) {
        yov_print_reports();
        os_console_wait();
        return;
    }
    
    String code = transpile_definitions(yov->temp_arena, (OpNode_Block*)main_script->ast);
    print_info(code);
    
    os_write_entire_file(core_h_path, { code.data, code.size });
}

String transpile_definitions(Arena* arena, OpNode_Block* ast)
{
    SCRATCH(arena);
    StringBuilder builder = string_builder_make(scratch.arena);
    
    appendf(&builder, "#pragma once\n\n");
    appendf(&builder, "internal_fn void define_core(Interpreter* inter)\n");
    appendf(&builder, "{\n");
    
    foreach(i, ast->ops.count)
    {
        OpNode* node0 = ast->ops[i];
        
        if (node0->kind == OpKind_StructDefinition)
        {
            OpNode_StructDefinition* node = (OpNode_StructDefinition*)node0;
            String name = node->identifier;
            
            indent(&builder, 1); appendf(&builder, "// struct %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            u32 in = 2;
            
            indent(&builder, in); appendf(&builder, "ObjectDefinition m[%u];\n", node->members.count);
            foreach(i, node->members.count) {
                OpNode_ObjectDefinition* member = node->members[i];
                String obj = transpile_definition_for_object_definition(scratch.arena, member);
                indent(&builder, in); appendf(&builder, "m[%u] = %S;\n", i, obj);
            }
            indent(&builder, in); append(&builder, "Array<ObjectDefinition> members = array_make(m, array_count(m));\n");
            
            indent(&builder, in); appendf(&builder, "define_struct(inter, STR(\"%S\"), members);\n", name);
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        if (node0->kind == OpKind_EnumDefinition)
        {
            OpNode_EnumDefinition* node = (OpNode_EnumDefinition*)node0;
            String name = node->identifier;
            
            indent(&builder, 1); appendf(&builder, "// enum %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            u32 in = 2;
            
            indent(&builder, in); appendf(&builder, "String n[%u];\n", node->names.count);
            foreach(i, node->names.count) {
                indent(&builder, in); appendf(&builder, "n[%u] = STR(\"%S\");\n", i, node->names[i]);
            }
            
            indent(&builder, in); append(&builder, "Array<String> names = array_make(n, array_count(n));\n");
            indent(&builder, in); appendf(&builder, "define_enum(inter, STR(\"%S\"), names, {});\n", name);
            
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        if (node0->kind == OpKind_FunctionDefinition)
        {
            OpNode_FunctionDefinition* node = (OpNode_FunctionDefinition*)node0;
            String name = node->identifier;
            
            u32 in = 2;
            
            indent(&builder, 1); appendf(&builder, "// function %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            indent(&builder, in); append(&builder, "Array<ObjectDefinition> parameters{};\n");
            if (node->parameters.count) {
                indent(&builder, in); appendf(&builder, "ObjectDefinition p[%u];\n", node->parameters.count);
                foreach(i, node->parameters.count) {
                    OpNode_ObjectDefinition* parameter = node->parameters[i];
                    String obj = transpile_definition_for_object_definition(scratch.arena, parameter);
                    indent(&builder, in); appendf(&builder, "p[%u] = %S;\n", i, obj);
                }
                indent(&builder, in); append(&builder, "parameters = array_make(p, array_count(p));\n");
            }
            
            String return_vtype = STR("VType_Void");
            if (node->return_node->kind == OpKind_ObjectType) {
                return_vtype = transpile_definition_for_object_type(scratch.arena, (OpNode_ObjectType*)node->return_node);
            }
            
            indent(&builder, in); appendf(&builder, "define_intrinsic_function(inter, {}, STR(\"%S\"), parameters, %S);\n", node->identifier, return_vtype);
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        if (node0->kind == OpKind_ObjectDefinition)
        {
            OpNode_ObjectDefinition* node = (OpNode_ObjectDefinition*)node0;
            if (!node->is_constant) continue;
            
            String name = node->object_name;
            
            u32 in = 2;
            
            indent(&builder, 1); appendf(&builder, "// global %S\n", name);
            indent(&builder, 1); append(&builder, "{\n");
            
            String type = {};
            
            if (node->type->name.size == 0) {
                if (node->assignment->kind == OpKind_FunctionCall) {
                    OpNode_FunctionCall* assignment = (OpNode_FunctionCall*)node->assignment;
                    type = string_format(scratch.arena, "vtype_from_name(inter, \"%S\")", assignment->identifier);
                }
                else {
                    assert(0);
                }
            }
            else {
                type = transpile_definition_for_object_type(scratch.arena, node->type);
            }
            
            indent(&builder, in); appendf(&builder, "Object* obj = define_object(inter, \"%S\", %S);\n", name, type);
            
            if (node->assignment->kind == OpKind_None) {}
            else if (node->assignment->kind == OpKind_FunctionCall) {}
            else {
                assert(0);
            }
            
            indent(&builder, 1); append(&builder, "}\n");
            
            continue;
        }
        
        assert(0);
    }
    
    appendf(&builder, "}\n");
    
    return string_from_builder(arena, &builder);
}

String transpile_definition_for_object_type(Arena* arena, OpNode_ObjectType* node)
{
    SCRATCH(arena);
    
    String type = string_format(scratch.arena, "vtype_from_name(inter, STR(\"%S\"))", node->name);
    if (node->array_dimensions) {
        type = string_format(scratch.arena, "vtype_from_array_dimension(inter, %S, %u)", type, node->array_dimensions);
    }
    
    return string_copy(arena, type);
}

String transpile_definition_for_object_definition(Arena* arena, OpNode_ObjectDefinition* node)
{
    SCRATCH(arena);
    
    String name = node->object_name;
    String type = transpile_definition_for_object_type(scratch.arena, node->type);
    
    return string_format(arena, "obj_def_make(STR(\"%S\"), %S)", name, type);
}