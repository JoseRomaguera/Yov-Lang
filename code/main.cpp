#include "inc.h"

YovScript* AddScript(String path)
{
    Assert(os_path_is_absolute(path));
    
    RBuffer raw_file;
    if (OsReadEntireFile(yov->arena, path, &raw_file).failed) {
        report_error(NO_CODE, "File '%S' not found\n", path);
        return NULL;
    }
    
    mutex_lock_guard(&yov->scripts_mutex);
    
    // Check for duplicated
    for (auto it = pooled_array_make_iterator(&yov->scripts); it.valid; ++it) {
        YovScript* s = it.value;
        if (StrEquals(s->path, path)) {
            return NULL;
        }
    }
    
    path = StrCopy(yov->arena, path);
    String text = StrFromRBuffer(raw_file);
    
    I32 script_id = yov->scripts.count;
    
    YovScript* script = array_add(&yov->scripts);
    script->id = script_id;
    script->path = path;
    script->name = path_get_last_element(path);
    script->dir = path_resolve(yov->arena, path_append(context.arena, path, ".."));
    script->text = text;
    return script;
}

#include "autogenerated/core.h"

YovScript* AddCoreScript()
{
    String text = YOV_CORE;
    
    I32 script_id = yov->scripts.count;
    
    YovScript* script = array_add(&yov->scripts);
    script->id = script_id;
    script->path = "core.yov";
    script->name = "core.yov";
    script->dir = "./";
    script->text = text;
    return script;
}

internal_fn B32 ExpectAndSkipBraces(Parser* parser, I32 script_id)
{
    Token open_brace_token = peek_token(parser);
    
    if (open_brace_token.kind != TokenKind_OpenBrace) {
        report_common_missing_opening_brace(open_brace_token.location);
        return false;
    }
    
    Location location = FetchScope(parser, TokenKind_OpenBrace, true);
    
    if (!LocationIsValid(location)) {
        report_common_missing_closing_brace(open_brace_token.location);
        return false;
    }
    
    return true;
}

internal_fn void ReadDefinitionsAndImports(YovScript* script, FrontContext* front, LaneGroup* lane_group)
{
    if (script == NULL) return;
    
    Parser* parser = ParserAlloc(script->text, { 0, script->text.size }, script->id);
    
    while (true)
    {
        Token t0 = peek_token(parser);
        if (t0.kind == TokenKind_None) break;
        
        Location start_location = t0.location;
        
        if (t0.kind == TokenKind_ImportKeyword)
        {
            skip_token(parser, t0);
            Token literal_token = consume_token(parser);
            Token semicolon_token = consume_token(parser);
            
            if (literal_token.kind != TokenKind_StringLiteral) {
                report_expecting_string_literal(start_location);
                break;
            }
            
            if (semicolon_token.kind != TokenKind_NextSentence) {
                report_expecting_semicolon(start_location);
                break;
            }
            
            String import_path = resolve_import_path(context.arena, script->dir, literal_token.value);
            YovScript* new_script = AddScript(import_path);
            
            if (new_script != NULL && lane_group != NULL) {
                LaneTaskAdd(lane_group, 1);
            }
        }
        else
        {
            SentenceKind op = find_sentence_kind(parser);
            
            if (op == SentenceKind_ObjectDef)
            {
                Location next_sentence = FetchUntil(parser, false, TokenKind_NextSentence);
                
                if (!LocationIsValid(next_sentence)) {
                    report_error(t0.location, "Missing semicolon");
                    continue;
                }
                
                Location location = LocationMake(t0.cursor, parser->cursor, script->id);
                
                mutex_lock(&front->mutex);
                array_add(&front->global_location_list, location);
                mutex_unlock(&front->mutex);
                
                assume_token(parser, TokenKind_NextSentence);
            }
            else if (op == SentenceKind_FunctionDef || op == SentenceKind_StructDef || op == SentenceKind_EnumDef || op == SentenceKind_ArgDef)
            {
                skip_token(parser, t0); // Identifier
                
                CodeDefinition def = {};
                def.identifier = t0.value;
                def.entire_location = NO_CODE;
                
                if (op == SentenceKind_FunctionDef) def.type = DefinitionType_Function;
                else if (op == SentenceKind_StructDef) def.type = DefinitionType_Struct;
                else if (op == SentenceKind_EnumDef) def.type = DefinitionType_Enum;
                else if (op == SentenceKind_ArgDef) def.type = DefinitionType_Arg;
                else InvalidCodepath();
                
                
                if (op == SentenceKind_StructDef || op == SentenceKind_EnumDef)
                {
                    assume_token(parser, TokenKind_Colon);
                    assume_token(parser, TokenKind_Colon);
                    assume_token(parser, (op == SentenceKind_StructDef) ? TokenKind_StructKeyword : TokenKind_EnumKeyword);
                    
                    U64 definition_start_cursor = parser->cursor;
                    if (!ExpectAndSkipBraces(parser, script->id)) break;
                    
                    def.enum_or_struct.body_location = LocationMake(definition_start_cursor, parser->cursor, script->id);
                }
                else if (op == SentenceKind_FunctionDef)
                {
                    assume_token(parser, TokenKind_Colon);
                    assume_token(parser, TokenKind_Colon);
                    assume_token(parser, TokenKind_FuncKeyword);
                    
                    def.function.parameters_location = NO_CODE;
                    def.function.returns_location = NO_CODE;
                    def.function.body_location = NO_CODE;
                    
                    // Parameters
                    if (peek_token(parser).kind == TokenKind_OpenParenthesis)
                    {
                        Location parameters_location = FetchScope(parser, TokenKind_OpenParenthesis, false);
                        
                        if (!LocationIsValid(parameters_location)) {
                            report_common_missing_closing_parenthesis(peek_token(parser).location);
                            continue;
                        }
                        
                        def.function.parameters_location = parameters_location;
                    }
                    
                    // Returns
                    if (peek_token(parser).kind == TokenKind_Arrow)
                    {
                        assume_token(parser, TokenKind_Arrow);
                        
                        Token first = peek_token(parser);
                        
                        def.function.return_is_list = first.kind == TokenKind_OpenParenthesis;
                        
                        if (def.function.return_is_list)
                        {
                            Location returns_location = FetchScope(parser, TokenKind_OpenParenthesis, false);
                            
                            if (!LocationIsValid(returns_location)) {
                                report_error(first.location, "Missing parenthesis for return");
                                continue;
                            }
                            
                            def.function.returns_location = returns_location;
                        }
                        else
                        {
                            Location returns_location = FetchUntil(parser, false, TokenKind_OpenBrace, TokenKind_NextSentence);
                            
                            if (!LocationIsValid(returns_location)) {
                                report_error(first.location, "Invalid return definition");
                                continue;
                            }
                            
                            def.function.returns_location = returns_location;
                        }
                    }
                    
                    // Body
                    {
                        if (peek_token(parser).kind == TokenKind_NextSentence) {
                            assume_token(parser, TokenKind_NextSentence);
                        }
                        else {
                            Location body_location = FetchCode(parser);
                            
                            if (!LocationIsValid(body_location)) {
                                report_error(peek_token(parser).location, "Expecting the body of the function");
                                continue;
                            }
                            
                            def.function.body_location = body_location;
                        }
                    }
                }
                else if (op == SentenceKind_ArgDef)
                {
                    assume_token(parser, TokenKind_Colon);
                    assume_token(parser, TokenKind_Colon);
                    assume_token(parser, TokenKind_ArgKeyword);
                    
                    def.arg.type_location = NO_CODE;
                    def.arg.body_location = NO_CODE;
                    
                    B32 has_type = false;
                    
                    if (peek_token(parser).kind == TokenKind_Arrow) {
                        assume_token(parser, TokenKind_Arrow);
                        has_type = true;
                    }
                    
                    Location to_open_brace = FetchUntil(parser, false, TokenKind_OpenBrace);
                    
                    if (!LocationIsValid(to_open_brace)) {
                        report_error(peek_token(parser).location, "Expecting braces for the arg");
                        continue;
                    }
                    
                    if (has_type) {
                        def.arg.type_location = to_open_brace;
                    }
                    
                    U64 start_cursor = parser->cursor;
                    
                    if (!ExpectAndSkipBraces(parser, script->id)) break;
                    
                    def.arg.body_location = LocationMake(start_cursor, parser->cursor, parser->script_id);
                }
                
                def.entire_location = LocationMake(t0.cursor, parser->cursor, script->id);
                
                {
                    mutex_lock_guard(&front->mutex);
                    DefinitionType type = def.type;
                    
                    if (type == DefinitionType_Function) front->function_count++;
                    else if (type == DefinitionType_Struct) front->struct_count++;
                    else if (type == DefinitionType_Enum) front->enum_count++;
                    else if (type == DefinitionType_Arg) front->arg_count++;
                    else {
                        InvalidCodepath();
                    }
                    
                    array_add(&front->definition_list, def);
                }
            }
            else
            {
                report_error(start_location, "Unsupported operation");
                // TODO(Jose): Skip tokens without breaking
                break;
            }
        }
    }
}

internal_fn void ReadAllScripts(LaneContext* lane, FrontContext* front)
{
    LaneGroup* group = lane->group;
    
    F64 start_time = TimerNow();
    
    if (LaneNarrow(lane, 0)) {
        
        LogFlow("Reading all scripts");
        
        AddScript(yov->main_script_path);
        
        if (!yov->settings.ignore_core)
            AddCoreScript();
    }
    
    LaneTaskStart(lane, yov->scripts.count);
    
    while (LaneDynamicTaskIsBusy(group))
    {
        U32 script_id;
        if (LaneTaskFetch(group, &script_id))
        {
            YovScript* script = GetScript(script_id);
            ReadDefinitionsAndImports(script, front, group);
            LaneDynamicTaskFinish(group);
        }
        else {
            OsThreadYield();
        }
    }
    
    if (LaneNarrow(lane, 0)) {
        front->definitions = array_from_pooled_array(front->arena, front->definition_list);
        
        F64 ellapsed = TimerNow() - start_time;
        LogFlow("Reading scripts finished: %S", StringFromEllapsedTime(ellapsed));
    }
    
    ArenaPopTo(context.arena, 0);
    LaneBarrier(lane);
}

internal_fn U32 CountIdentifiers(String identifier)
{
    U32 count = 0;
    
    foreach(i, yov->definitions.count) {
        if (yov->definitions[i].header.identifier == identifier) count++;
    }
    
    return count;
}

void IdentifyDefinitions(LaneContext* lane, FrontContext* front)
{
    if (LaneNarrow(lane))
    {
        U32 definition_count = 0;
        definition_count += front->function_count;
        definition_count += front->struct_count;
        definition_count += front->enum_count;
        definition_count += front->arg_count;
        
        yov->definitions = array_make<Definition>(yov->arena, definition_count);
        yov->function_count = front->function_count;
        yov->struct_count = front->struct_count;
        yov->enum_count = front->enum_count;
        yov->arg_count = front->arg_count;
    }
    
    LaneBarrier(lane);
    
    // Identify
    {
        RangeU32 range = LaneDistributeUniformWork(lane, front->definitions.count);
        
        for (U32 i = range.min; i < range.max; ++i)
        {
            CodeDefinition* code = &front->definitions[i];
            
            code->index = AtomicIncrementU32(&front->index_counter) - 1;
            DefinitionIdentify(code->index, code->type, code->identifier, code->entire_location);
        }
        
        LaneBarrier(lane);
    }
    
    // Check for duplications
    {
        RangeU32 range = LaneDistributeUniformWork(lane, yov->definitions.count);
        
        for (U32 i = range.min; i < range.max; ++i)
        {
            DefinitionHeader* def = &yov->definitions[i].header;
            
            U32 count = CountIdentifiers(def->identifier);
            
            if (count > 1) {
                report_error(def->location, "Duplicated definition '%S'", def->identifier);
                continue;
            }
        }
        
        LaneBarrier(lane);
    }
    
    Assert(front->index_counter == yov->definitions.count);
}

void DefineDefinitions(LaneContext* lane, FrontContext* front)
{
    RangeU32 range = LaneDistributeUniformWork(lane, front->definitions.count);
    
    for (U32 i = range.min; i < range.max; ++i)
    {
        CodeDefinition* code = &front->definitions[i];
        
        if (code->type == DefinitionType_Enum) {
            ReadEnumDefinition(code);
        }
        else if (code->type == DefinitionType_Struct) {
            ReadStructDefinition(code);
        }
        else if (code->type == DefinitionType_Function) {
            ReadFunctionDefinition(code);
        }
        else {
            ReadArgDefinition(code);
        }
    }
    
    LaneBarrier(lane);
}

internal_fn void DefineLangGlobal(FrontContext* front, String name, String type)
{
    Global global = {};
    global.identifier = name;
    global.vtype = vtype_from_name(type);
    global.is_constant = true;
    global.reference = ref_from_object(null_obj);
    
    mutex_lock_hot(&front->mutex);
    array_add(&front->global_list, global);
    mutex_unlock(&front->mutex);
}

void DefineGlobals(LaneContext* lane, FrontContext* front)
{
    if (LaneNarrow(lane))
    {
        DefineLangGlobal(front, "yov", "YovInfo");
        DefineLangGlobal(front, "os", "OS");
        DefineLangGlobal(front, "context", "Context");
        DefineLangGlobal(front, "calls", "CallsContext");
    }
    
    RangeU32 code_range = LaneDistributeUniformWork(lane, front->global_location_list.count);
    
    // Define code globals
    {
        for (U32 i = code_range.min; i < code_range.max; ++i)
        {
            Location location = front->global_location_list[i];
            
            ObjectDefinitionResult res = ReadObjectDefinition(context.arena, location, false, RegisterKind_Global, NULL);
            if (!res.success) continue;
            
            Array<Global> globals = array_make<Global>(context.arena, res.objects.count);
            
            foreach(i, globals.count)
            {
                ObjectDefinition def = res.objects[i];
                
                Global global = {};
                global.identifier = StrCopy(yov->arena, def.name);
                global.vtype = def.vtype;
                global.is_constant = def.is_constant;
                global.reference = ref_from_object(null_obj);
                
                Assert(VTypeValid(def.vtype));
                
                globals[i] = global;
            }
            
            mutex_lock_hot(&front->mutex);
            foreach(i, globals.count)
                array_add(&front->global_list, globals[i]);
            mutex_unlock(&front->mutex);
        }
        
        LaneBarrier(lane);
    }
    
    // Define args globals
    if (LaneNarrow(lane))
    {
        foreach(i, yov->definitions.count)
        {
            ArgDefinition def = yov->definitions[i].arg;
            if (def.type != DefinitionType_Arg) continue;
            
            
            Global global = {};
            global.identifier = StrCopy(yov->arena, def.identifier);
            global.vtype = def.vtype;
            global.is_constant = true;
            global.reference = ref_from_object(null_obj);
            
            Assert(VTypeValid(def.vtype));
            
            array_add(&front->global_list, global);
        }
    }
    LaneBarrier(lane);
    
    if (LaneNarrow(lane)) {
        yov->globals = array_from_pooled_array(yov->arena, front->global_list);
    }
    LaneBarrier(lane);
}

void ResolveGlobals(LaneContext* lane, FrontContext* front)
{
    // Code globals
    {
        RangeU32 code_range = LaneDistributeUniformWork(lane, front->global_location_list.count);
        
        for (U32 i = code_range.min; i < code_range.max; ++i)
        {
            Location location = front->global_location_list[i];
            
            IR_Context* ir_context = ir_context_alloc();
            
            ObjectDefinitionResult res = ReadObjectDefinition(context.arena, location, false, RegisterKind_Global, ir_context);
            if (!res.success) continue;
            
            mutex_lock_hot(&front->mutex);
            front->global_initialize_group = ir_append(front->global_initialize_group, res.out);
            front->number_of_registers_for_global_initialize = Max(front->number_of_registers_for_global_initialize, ir_context->local_registers.count);
            mutex_unlock(&front->mutex);
        }
    }
    LaneBarrier(lane);
    
    
    if (LaneNarrow(lane))
    {
        // Args
        {
            IR_Context* ir_context = ir_context_alloc();
            
            foreach(i, yov->definitions.count)
            {
                ArgDefinition* def = &yov->definitions[i].arg;
                if (def->type != DefinitionType_Arg) continue;
                
                Value value = def->default_value;
                
                ScriptArg* script_arg = yov_find_script_arg(def->name);
                
                if (script_arg == NULL) {
                    if (def->required) {
                        report_arg_is_required(def->location, def->name);
                        continue;
                    }
                }
                else
                {
                    value = ValueNone();
                    
                    if (script_arg->value.size <= 0)
                    {
                        if (def->vtype == VType_Bool) {
                            value = ValueFromBool(true);
                        }
                    }
                    else
                    {
                        value = ValueFromStringExpression(yov->arena, script_arg->value, def->vtype);
                    }
                    
                    if (value.kind == ValueKind_None) {
                        report_arg_wrong_value(NO_CODE, def->name, script_arg->value);
                        continue;
                    }
                }
                
                I32 global_index = GlobalIndexFromIdentifier(def->identifier);
                
                if (global_index >= 0)
                {
                    front->global_initialize_group = ir_append(front->global_initialize_group, ir_from_store(ir_context, ValueFromGlobal(global_index), value, def->location));
                    front->number_of_registers_for_global_initialize = Max(front->number_of_registers_for_global_initialize, ir_context->local_registers.count);
                }
            }
        }
        
        if (front->global_initialize_group.success)
        {
            Array<Register> registers = array_make<Register>(context.arena, front->number_of_registers_for_global_initialize);
            
            foreach(i, registers.count)
            {
                Register reg = {};
                reg.kind = RegisterKind_Local;
                reg.is_constant = false;
                reg.vtype = VType_Any;
                
                registers[i] = reg;
            };
            
            yov->globals_initialize_ir = MakeIR(yov->arena, registers, front->global_initialize_group);
        }
    }
    
    LaneBarrier(lane);
}

void ResolveDefinitions(LaneContext* lane, FrontContext* front)
{
    while (front->resolve_count < front->definitions.count)
    {
        RangeU32 range = LaneDistributeUniformWork(lane, front->definitions.count);
        
        for (U32 i = range.min; i < range.max; ++i)
        {
            CodeDefinition* code = &front->definitions[i];
            
            B32 resolved = false;
            
            if (code->type == DefinitionType_Enum) {
                resolved = true;
                EnumDefinition* def = EnumFromIndex(code->index);
                ResolveEnumDefinition(def);
            }
            else if (code->type == DefinitionType_Struct) {
                StructDefinition* def = StructFromIndex(code->index);
                resolved = ResolveStructDefinition(def);
            }
            else if (code->type == DefinitionType_Function) {
                resolved = true;
                FunctionDefinition* def = FunctionFromIndex(code->index);
                ResolveFunctionDefinition(def, code);
            }
            else {
                resolved = true;
                ResolveArgDefinition(code);
            }
            
            if (resolved) {
                AtomicIncrementU32(&front->resolve_count);
            }
        }
        
        LaneBarrier(lane);
        
        if (LaneNarrow(lane))
        {
            if (front->resolve_count < front->definitions.count)
            {
                if (front->last_resolve_count == front->resolve_count) {
                    InvalidCodepath();
                    front->resolve_count = front->definitions.count;
                }
                else {
                    front->last_resolve_count = front->resolve_count;
                    front->resolve_count = 0;
                }
            }
            
            front->resolve_iterations++;
        }
        
        LaneBarrier(lane);
    }
    
    if (LaneNarrow(lane)) {
        LogFlow("Resove iterations: %u", front->resolve_iterations);
    }
    
    LaneBarrier(lane);
}

internal_fn void yov_run_wide(LaneContext* lane)
{
    FrontContext* front = NULL;
    
    if (LaneNarrow(lane, 0)) {
        Arena* front_arena = ArenaAlloc(Gb(32), 8);
        front = ArenaPushStruct<FrontContext>(front_arena);
        front->arena = front_arena;
        front->definition_list = pooled_array_make<CodeDefinition>(front_arena, 64);
        front->global_location_list = pooled_array_make<Location>(front_arena, 32);
        front->global_list = pooled_array_make<Global>(front_arena, 32);
        front->global_initialize_group = ir_from_none();
    }
    
    LaneSyncPtr(lane, (void**)&front, 0);
    
    ReadAllScripts(lane, front);
    
    if (yov->scripts.count == 0) {
        if (LaneNarrow(lane)) {
            yov->exit_requested = true;
            yov_set_exit_code(-1);
        }
        return;
    }
    
    // Identify Pass
    {
        if (LaneNarrow(lane)) {
            LogFlow("Starting Identify Pass");
        }
        
        F64 start_time = TimerNow();
        
        IdentifyDefinitions(lane, front);
        
        if (LaneNarrow(lane)) {
            YovInitializeTypesTable();
            
            F64 ellapsed = TimerNow() - start_time;
            LogFlow("Identify pass finished: %S", StringFromEllapsedTime(ellapsed));
        }
        
        ArenaPopTo(context.arena, 0);
        LaneBarrier(lane);
        
        if (yov->exit_requested) {
            if (LaneNarrow(lane)) yov_set_exit_code(-1);
            return;
        }
    }
    
    // Define Pass
    {
        if (LaneNarrow(lane)) {
            LogFlow("Starting Define Pass");
        }
        
        F64 start_time = TimerNow();
        
        DefineDefinitions(lane, front);
        DefineGlobals(lane, front);
        
        ArenaPopTo(context.arena, 0);
        LaneBarrier(lane);
        
        if (LaneNarrow(lane)) {
            F64 ellapsed = TimerNow() - start_time;
            LogFlow("Define pass finished: %S", StringFromEllapsedTime(ellapsed));
        }
        
        if (yov->exit_requested) {
            if (LaneNarrow(lane)) yov_set_exit_code(-1);
            return;
        }
    }
    
    // Resolve Pass
    {
        if (LaneNarrow(lane)) {
            LogFlow("Starting Resolve Pass");
        }
        
        F64 start_time = TimerNow();
        
        ResolveDefinitions(lane, front);
        ResolveGlobals(lane, front);
        
        ArenaPopTo(context.arena, 0);
        LaneBarrier(lane);
        
        if (LaneNarrow(lane)) {
            F64 ellapsed = TimerNow() - start_time;
            LogFlow("Resolve pass finished: %S", StringFromEllapsedTime(ellapsed));
        }
        
        if (yov->exit_requested) {
            if (LaneNarrow(lane)) yov_set_exit_code(-1);
            return;
        }
    }
    
    // Init Globals
    if (LaneNarrow(lane))
    {
        LogFlow("Starting Init Globals");
        F64 start_time = TimerNow();
        
        
        InitializeLanguageGlobals();
        if (yov->globals_initialize_ir.success)
        {
            ExecuteIr(yov->globals_initialize_ir, {}, {}, NO_CODE);
        }
        
        F64 ellapsed = TimerNow() - start_time;
        LogFlow("Init globals finished: %S", StringFromEllapsedTime(ellapsed));
    }
    ArenaPopTo(context.arena, 0);
    LaneBarrier(lane);
    
#if 0
    if (help_arg != NULL) {
        yov_print_script_help();
        return;
    }
#endif
    
    if (LaneNarrow(lane))
    {
#if LOG_IR_ENABLED
        PrintIr("Initialize Globals", yov->globals_initialize_ir);
        foreach(i, yov->definitions.count)
        {
            DefinitionHeader* header = &yov->definitions[i].header;
            if (header->type == DefinitionType_Function) {
                FunctionDefinition* fn = &yov->definitions[i].function;
                if (fn->is_intrinsic) continue;
                PrintIr(fn->identifier, fn->defined.ir);
            }
        }
#endif
        
        // Execute
        if (!yov->settings.analyze_only) {
            LogFlow("Starting Execution");
            LogFlow(SEPARATOR_STRING);
            F64 start_time = TimerNow();
            
            interpreter_run_main();
            
            F64 ellapsed = TimerNow() - start_time;
            LogFlow("Execution finished: %S", StringFromEllapsedTime(ellapsed));
        }
        
        interpreter_finish();
        
        if (yov->exit_requested && yov->reports.count > 0) {
            yov_set_exit_code(-1);
        }
    }
    
    ArenaPopTo(context.arena, 0);
}


int main()
{
    OsSetupSystemInfo();
    
    yov_initialize_thread();
    
    yov_initialize();
    
    yov_config_from_args();
    
    if (!yov->exit_requested) {
        LaneGroup* group = LaneGroupStart(yov->arena, yov_run_wide);
        LaneGroupWait(group);
    }
    yov_print_reports();
    I64 exit_code = yov->exit_code;
    
    yov_shutdown();
    yov_shutdown_thread();
    
    return (I32)exit_code;
}

