
indent :: (count: Int) -> String {
    str := "";
    for (i := 0; i < count; i += 1) str += '\t';
    return str;
}

transpile_script :: (script_path: String, result_path: String) -> Result
{
    out := yov_parse(script_path);
    // print_parsing(out);
    
    if (out.reports.count > 0) {
        for (report: out.reports) {
            println(report);
        }
        return failed("Can't parse script", -1);
    }
    
    head := "#pragma once\n\n";
    
    head += "void YovDefineCore();\n";
    head += "void YovResolveCore();\n";
    head += "\n";
    
    for (fn: out.functions) {
        head += "void intrinsic__{fn.identifier}(Interpreter* inter, Array<Reference> params, Array<Reference> returns, Location location);\n";
    }
    head += "\n";
    
    // Enums Array
    head += "static const char* core_enum_definitions[] = \{\n";
    for (def: out.enums) {
        head += "{indent(1)}\"{def.identifier}\",\n";
    }
    head += "\};\n\n";
    
    // Structs Array
    head += "static const char* core_struct_definitions[] = \{\n";
    for (def: out.structs) {
        head += "{indent(1)}\"{def.identifier}\",\n";
    }
    head += "\};\n\n";
    
    // Functions Array
    head += "static const char* core_function_definitions[] = \{\n";
    for (def: out.functions) {
        head += "{indent(1)}\"{def.identifier}\",\n";
    }
    head += "\};\n\n";
    
    // Globals Array
    head += "static const char* core_global_definitions[] = \{\n";
    for (def: out.globals) {
        head += "{indent(1)}\"{def.identifier}\",\n";
    }
    head += "\};\n\n";
    
    src := "\n";
    
    src += "#include \"inc.h\"\n\n";
    
    src += "void YovDefineCore()\n";
    src += "\{\n";
    
    for (def: out.enums)
    {
        src += "{indent(1)}// {string_from_enum_definition(def)}\n";
        src += "{indent(1)}\{\n";
        src += transpile_string_array(2, "names", def.elements);
        src += "{indent(2)}EnumDefinition* def = EnumFromIdentifier(\"{def.identifier}\");\n";
        src += "{indent(2)}EnumDefine(def, names);\n";
        src += "{indent(1)}\}\n";
    }
    
    for (def: out.structs)
    {
        src += "{indent(1)}// {string_from_struct_definition(def)}\n";
        src += "{indent(1)}\{\n";
        src += transpile_object_definition_array(2, "members", def.members);
        src += "{indent(2)}StructDefinition* def = StructFromIdentifier(\"{def.identifier}\");\n";
        src += "{indent(2)}StructDefine(def, members);\n";
        src += "{indent(1)}\}\n";
    }
    
    for (fn: out.functions)
    {
        src += "{indent(1)}// {string_from_function_definition(fn)}\n";
        src += "{indent(1)}\{\n";
        src += transpile_object_definition_array(2, "parameters", fn.parameters);
        src += transpile_object_definition_array(2, "returns", fn.returns);
        src += "{indent(2)}FunctionDefinition* def = FunctionFromIdentifier(\"{fn.identifier}\");\n";
        src += "{indent(2)}FunctionDefine(def, parameters, returns);\n";
        src += "{indent(1)}\}\n";
    }
    
    for (def: out.globals)
    {
        vtype := "vtype_from_name(\"{def.type.name}\")";
        
        src += "{indent(1)}// {string_from_object_definition(def)}\n";
        src += "{indent(1)}\{\n";
        src += "{indent(2)}I32 index = GlobalIndexFromIdentifier(\"{def.identifier}\");\n";
        src += "{indent(2)}GlobalDefine(index, {vtype}, {def.is_constant});\n";
        src += "{indent(1)}\}\n";
    }
    
    src += "\}\n\n";
    
    src += "void YovResolveCore()\n";
    src += "\{\n";
    
    for (def: out.enums)
    {
        src += "{indent(1)}// {string_from_enum_definition(def)}\n";
        src += "{indent(1)}\{\n";
        src += transpile_int_array(2, "values", def.values);
        src += "{indent(2)}EnumDefinition* def = EnumFromIdentifier(\"{def.identifier}\");\n";
        src += "{indent(2)}EnumResolve(def, values);\n";
        src += "{indent(1)}\}\n";
    }
    
    for (def: out.structs)
    {
        src += "{indent(1)}// {string_from_struct_definition(def)}\n";
        src += "{indent(1)}\{\n";
        src += "{indent(2)}StructDefinition* def = StructFromIdentifier(\"{def.identifier}\");\n";
        src += "{indent(2)}StructResolve(def);\n";
        src += "{indent(1)}\}\n";
    }
    
    for (fn: out.functions)
    {
        src += "{indent(1)}// {string_from_function_definition(fn)}\n";
        src += "{indent(1)}\{\n";
        src += "{indent(2)}FunctionDefinition* def = FunctionFromIdentifier(\"{fn.identifier}\");\n";
        src += "{indent(2)}FunctionResolveIntrinsic(def, intrinsic__{fn.identifier});\n";
        src += "{indent(1)}\}\n";
    }
    
    src += "\}\n";
    
    write_entire_file(result_path / "core.h", head);
    write_entire_file(result_path / "core.cpp", src);
    
    return Result();
}

transpile_object_definition :: (def: ObjectDefinition) -> String
{
    vtype := "vtype_from_name(\"{def.type.name}\")";
    return "obj_def_make(\"{def.identifier}\", {vtype}, NO_CODE, {def.is_constant}, value_from_zero({vtype}))";
}

transpile_object_definition_array :: (in: Int, name: String, defs: ObjectDefinition[]) -> String
{
    values := [defs.count]->String;
    for (def, i: defs) {
        values[i] = transpile_object_definition(def);
    }
    return transpile_array(in, name, "ObjectDefinition", values);
}

transpile_string_array :: (in: Int, name: String, strings: String[]) -> String
{
    values := [strings.count]->String;
    for (str, i: strings) {
        values[i] = "\"{str}\"";
    }
    return transpile_array(in, name, "String", values);
}

transpile_int_array :: (in: Int, name: String, ints: Int[]) -> String
{
    values := [ints.count]->String;
    for (int, i: ints) {
        values[i] = "{int}";
    }
    return transpile_array(in, name, "I64", values);
}

transpile_array :: (in: Int, name: String, type: String, values: String[]) -> String
{
    str := "";
    if (values.count > 0)
    {
        str += "{indent(in)}{type} {name}_[{values.count}];\n";
        for (v, i: values) {
            str += "{indent(in)}{name}_[{i}] = {values[i]};\n";
        }
        str += "{indent(in)}Array<{type}> {name} = array_make({name}_, countof({name}_));\n";
    }
    else
    {
        str += "{indent(in)}Array<{type}> {name} = \{\};\n";
    }
    return str;
}

print_parsing :: (out: YovParseOutput)
{
    println("-> Functions ({out.functions.count}):");
    for (o, i : out.functions) {
        println(string_from_function_definition(o));
    }
    
    println("-> Structs ({out.structs.count}):");
    for (o, i : out.structs) {
        println(string_from_struct_definition(o));
    }
    
    println("-> Enums ({out.enums.count}):");
    for (o, i : out.enums) {
        println(string_from_enum_definition(o));
    }
    
    println("-> Globals ({out.globals.count}):");
    for (o, i : out.globals) {
        println(string_from_object_definition(o));
    }
}

string_from_function_definition :: (fn: FunctionDefinition) -> String
{
    str := "{fn.identifier} :: (";
    str += string_from_object_definition_array(fn.parameters);
    str += ")";
    
    if (fn.returns.count > 0) {
        str += " -> ";
        
        if (fn.returns.count == 1 && fn.returns[0].identifier == "return") {
            str += fn.returns[0].type.name;
        }
        else {
            str += "({string_from_object_definition_array(fn.returns)})";
        }
    }
    
    return str + ";";
}

string_from_struct_definition :: (def: StructDefinition) -> String
{
    str := "{def.identifier} :: struct \{ ";
    str += string_from_object_definition_array(def.members);
    str += " \}";
    return str;
}

string_from_enum_definition :: (def: EnumDefinition) -> String
{
    str := "{def.identifier} :: enum \{ ";
    for (e, i: def.elements) {
        v := def.values[i];
        
        str += e;
        if (v != i) str += " = {v}";
        if (i < def.elements.count - 1) str += ", ";
    }
    str += " \}";
    return str;
}

string_from_object_definition :: (o: ObjectDefinition) -> String {
    return "{o.identifier}: {o.type.name}";
}

string_from_object_definition_array :: (objects: ObjectDefinition[]) -> String {
    str := "";
    for (o, i: objects) {
        str += string_from_object_definition(o);
        if (i < objects.count - 1) str += ", ";
    }
    return str;
}
